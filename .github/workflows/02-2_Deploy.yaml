name: 02-2 - Deploy to Azure VM
on:
  workflow_call

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts
          path: ./deployment/

      - name: Setup SSH key and known hosts
        run: |
          # Cr√©er le r√©pertoire SSH
          mkdir -p ~/.ssh
          
          # Ajouter la cl√© priv√©e
          echo "${{ secrets.AZURE_VM_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Ajouter l'host dans known_hosts pour √©viter la v√©rification
          ssh-keyscan -H ${{ secrets.AZURE_VM_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          
          # V√©rifier la connexion SSH
          ssh -o ConnectTimeout=10 -i ~/.ssh/id_rsa ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_HOST }} "echo 'SSH connection successful'"

      - name: Copy deployment files to server
        run: |
          scp -i ~/.ssh/id_rsa -r ./deployment/* ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_HOST }}:~/cesizen/

      - name: Deploy application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_HOST }} << 'ENDSSH'
            cd ~/cesizen
            
            # Afficher les informations de d√©bogage
            echo "üîç Variables d'environnement:"
            echo "REGISTRY: ${{ env.REGISTRY }}"
            echo "IMAGE_NAME: ${{ env.IMAGE_NAME }}"
            
            # Configurer les variables d'environnement
            export SQL_SERVER_PASSWORD="${{ secrets.SQL_SERVER_PASSWORD }}"
            
            # Se connecter au registre Docker
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # D√©terminer la commande docker compose disponible
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            else
              echo "‚ùå Ni docker-compose ni docker compose n'est disponible"
              echo "Installation de docker-compose..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              DOCKER_COMPOSE="docker-compose"
            fi
            echo "‚úÖ Utilisation de: $DOCKER_COMPOSE"
            
            # Mettre √† jour le fichier docker-compose avec les bonnes images
            echo "üîÑ Mise √† jour des images dans docker-compose.yml"
            sed -i 's|ghcr.io/votre-username/cesizen-api:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest|g' docker-compose.yml
            sed -i 's|ghcr.io/votre-username/cesizen-ui:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-ui:latest|g' docker-compose.yml
            
            # V√©rifier le contenu du fichier docker-compose
            echo "üìÑ Contenu du docker-compose.yml (lignes avec images):"
            grep "image:" docker-compose.yml || echo "Aucune ligne 'image:' trouv√©e"
            
            # Modifier le script deploy.sh pour utiliser la bonne commande
            if [ -f "deploy.sh" ]; then
              sed -i "s/docker-compose/\$DOCKER_COMPOSE/g" deploy.sh
              echo "‚úÖ Script deploy.sh mis √† jour"
            else
              echo "‚ö†Ô∏è Fichier deploy.sh non trouv√©"
            fi
            
            # Ex√©cuter le script de d√©ploiement
            chmod +x deploy.sh
            ./deploy.sh
            
            # V√©rifier que les services sont d√©marr√©s
            echo "üîç √âtat des services:"
            $DOCKER_COMPOSE ps
            
            # Compter les services en cours d'ex√©cution
            RUNNING_SERVICES=$($DOCKER_COMPOSE ps --filter "status=running" -q | wc -l)
            echo "Services en cours d'ex√©cution: $RUNNING_SERVICES"
            
            # Afficher les logs en cas de probl√®me
            if [ "$RUNNING_SERVICES" -lt 3 ]; then
              echo "‚ùå Certains services ne sont pas d√©marr√©s correctement"
              echo "üìã Logs des services:"
              $DOCKER_COMPOSE logs --tail=50
              exit 1
            else
              echo "‚úÖ Tous les services sont op√©rationnels"
            fi
          ENDSSH

      - name: Health check
        run: |
          # Attendre un peu que les services soient compl√®tement pr√™ts
          sleep 60
          
          # Test de sant√© de l'application UI
          if curl -f -s --max-time 30 http://${{ secrets.AZURE_VM_HOST }}/ > /dev/null; then
            echo "‚úÖ Application UI accessible"
          else
            echo "‚ùå Application UI non accessible"
            exit 1
          fi
          
          # Test de sant√© de l'API
          if curl -f -s --max-time 30 http://${{ secrets.AZURE_VM_HOST }}:5000/swagger > /dev/null; then
            echo "‚úÖ API accessible"
          else
            echo "‚ùå API non accessible"
            exit 1
          fi

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

      - name: Notify deployment success
        if: success()
        run: |
          echo "üéâ D√©ploiement r√©ussi!"
          echo "üåê Application disponible sur: http://${{ secrets.AZURE_VM_HOST }}"
          echo "üìö API Swagger: http://${{ secrets.AZURE_VM_HOST }}:5000/swagger"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå √âchec du d√©ploiement"
          echo "Consultez les logs pour plus de d√©tails"