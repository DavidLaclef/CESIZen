name: 02-2 - Deploy to Azure VM
on:
  workflow_call
jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts
          path: ./deployment/

      - name: Setup SSH key and known hosts
        run: |
          # Cr√©er le r√©pertoire SSH
          mkdir -p ~/.ssh
          
          # Ajouter la cl√© priv√©e
          echo "${{ secrets.AZURE_VM_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Ajouter l'host dans known_hosts pour √©viter la v√©rification
          ssh-keyscan -H ${{ secrets.AZURE_VM_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          
          # V√©rifier la connexion SSH
          ssh -o ConnectTimeout=10 -i ~/.ssh/id_rsa ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_HOST }} "echo 'SSH connection successful'"

      - name: Copy deployment files to server
        run: |
          scp -i ~/.ssh/id_rsa -r ./deployment/* ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_HOST }}:~/cesizen/

      - name: Deploy application
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.AZURE_VM_USER }}@${{ secrets.AZURE_VM_HOST }} << 'ENDSSH'
            cd ~/cesizen
            
            # Configurer les variables d'environnement
            export SQL_SERVER_PASSWORD="${{ secrets.SQL_SERVER_PASSWORD }}"
            
            # Se connecter au registre Docker
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Mettre √† jour le fichier docker-compose avec les bonnes images
            sed -i 's|ghcr.io/votre-username/cesizen-api:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest|g' docker-compose.yml
            sed -i 's|ghcr.io/votre-username/cesizen-ui:latest|${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-ui:latest|g' docker-compose.yml
            
            # Ex√©cuter le script de d√©ploiement
            chmod +x deploy.sh
            ./deploy.sh
            
            # V√©rifier que les services sont d√©marr√©s
            docker-compose ps
            
            # Afficher les logs en cas de probl√®me
            if [ "$(docker-compose ps | grep -c 'Up')" -lt 3 ]; then
              echo "‚ùå Certains services ne sont pas d√©marr√©s correctement"
              docker-compose logs
              exit 1
            else
              echo "‚úÖ Tous les services sont op√©rationnels"
            fi
          ENDSSH

      - name: Health check
        run: |
          # Attendre un peu que les services soient compl√®tement pr√™ts
          sleep 60
          
          # Test de sant√© de l'application UI
          if curl -f -s --max-time 30 http://${{ secrets.AZURE_VM_HOST }}/ > /dev/null; then
            echo "‚úÖ Application UI accessible"
          else
            echo "‚ùå Application UI non accessible"
            exit 1
          fi
          
          # Test de sant√© de l'API
          if curl -f -s --max-time 30 http://${{ secrets.AZURE_VM_HOST }}:5000/swagger > /dev/null; then
            echo "‚úÖ API accessible"
          else
            echo "‚ùå API non accessible"
            exit 1
          fi

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

      - name: Notify deployment success
        if: success()
        run: |
          echo "üéâ D√©ploiement r√©ussi!"
          echo "üåê Application disponible sur: http://${{ secrets.AZURE_VM_HOST }}"
          echo "üìö API Swagger: http://${{ secrets.AZURE_VM_HOST }}:5000/swagger"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå √âchec du d√©ploiement"
          echo "Consultez les logs pour plus de d√©tails"